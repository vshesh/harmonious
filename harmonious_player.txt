# Welcome to Sonic Pi v3.0.1

set :looping?, false
set :tower1, [0, -1]
set :tower2, [0, -1]
set :tower3, [0, -1]
set :tower4, [0, -1]

#uses index to map the chord - 1-7 are as positioned (dummy argument in zero)
fiducial_map = [
  (ring 0, 7, 12, 16, 19, 24),
  (ring 0, 7, 10, 12, 15),
  (ring 0, 7, 10, 12, 15),
  (ring 0, 7, 12, 16, 19),
  (ring 0, 4, 7, 10, 16),
  (ring 0, 3, 7, 12, 15),
  (ring 0, 3, 6, 10)
]

define :shift do |n, iterable|
  l = []
  d = note(n)
  iterable.each do |e|
    l.push (e+d)
  end
  l
end

define :make_key do |tonic|
  l = [[]]
  maj = (scale :major)
  [0,1,2,3,4,5,6].each do |i|
    puts i
    l.push shift note(tonic)+maj[i], fiducial_map[i]
  end
  l
end

key_c = make_key :C3
play key_c[1]

define :get_tower_number do |x|
  # subtract margins and then take a quadrant
  # scale x to be in 0.05 - 0.95
  scaled = (x-0.05)/(0.95-0.05)
  if scaled <= 0.25 
    4
  else 
    if x <= 0.5  
      3 
    else 
      if x <= 0.75  
        2 
      else  
        1 
      end
    end
  end
end

# check for the fiducials
live_loop :fiducials do
  use_real_time
  id, x, y, angle = sync "/osc/tuio/fiducial"
  tower = get_tower_number x
  set :tower1, [id, angle] if tower == 1
  set :tower2, [id, angle] if tower == 2
  set :tower3, [id, angle] if tower == 3
  set :tower4, [id, angle] if tower == 4
end


live_loop :buttons do
  use_real_time
  id, state = sync "/osc/button"
  set :looping?, if state == 1 then true else false end if id == 0
end

# setup main loop
live_loop :progression do
  use_osc "localhost", 3334
  puts get[:tower1][0], get[:tower1][1]
  osc "/light", if get[:looping?] then 1 else -1 end, 4 
  play key_c[get[:tower1][0]] if get[:looping?] and get[:tower1][1] >= 0
  sleep 1
  play key_c[get[:tower1][0]] if get[:looping?] and get[:tower1][1] >= 0
  sleep 1
  osc "/light", if get[:looping?] then 2 else -1 end, 1
  play key_c[get[:tower2][0]] if get[:looping?] and get[:tower2][1] >= 0
  sleep 1
  play key_c[get[:tower2][0]] if get[:looping?] and get[:tower2][1] >= 0
  sleep 1
  osc "/light", if get[:looping?] then 3 else -1 end, 2 
  play key_c[get[:tower3][0]] if get[:looping?] and get[:tower3][1] >= 0
  sleep 1
  play key_c[get[:tower3][0]] if get[:looping?] and get[:tower3][1] >= 0
  sleep 1
  osc "/light", if get[:looping?] then 4 else -1 end, 3
  play key_c[get[:tower4][0]] if get[:looping?] and get[:tower4][1] >= 0
  sleep 1
  play key_c[get[:tower4][0]] if get[:looping?] and get[:tower4][1] >= 0
  sleep 1
end


set :note1, nil
key_c = make_key :C3

# individual loops for each chord when user presses button
# note have to set the amplitude of the running note to on or off based on the button being pressed
##| live_loop :playbutton1 do
##|   set :note1, (play key_c[1], amp: 0, attack: 0.2, sustain: 99.8)
##|   sleep 100
##| end

